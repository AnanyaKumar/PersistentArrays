\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}Introduction}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Previous Approaches}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Dynamics}{1}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Approach}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces New functional array filled with 0s}}{1}}
\newlabel{fig:new_array_A}{{1}{1}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces $B = set(A, 3, 5)$ changes the array in $AD$ and adds a log entry.}}{2}}
\newlabel{fig:set_A_return_B}{{2}{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces $D = set(A, 1, 9)$ copies $AD$ because $A$ is OLD}}{2}}
\newlabel{fig:set_old_array}{{3}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Cost Dynamics}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Concurrent Implementation}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}Concurrency Model}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}Push Arrays}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Functional Array Implementation}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4}Proof of Correctness}{3}}
\bibstyle{abbrvnat}
\bibdata{references}
\@writefile{toc}{\contentsline {section}{\numberline {7}Correctness}{4}}
\@writefile{toc}{\contentsline {section}{\numberline {8}Machine Model}{4}}
\newlabel{sigplanconf@finalpage}{{8}{4}}
